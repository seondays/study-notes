## Cookie와 Session [📑](https://www.tutorialspoint.com/What-is-the-difference-between-session-and-cookies)
쿠키와 세션은 둘 다 웹에서 상태를 유지하고 정보를 저장하는 데 사용한다.

### 차이점!  
  → 쿠키는 클라이언트의 컴퓨터에만 저장  
  → 세션은 서버에만 저장 (세션이 클라이언트에도 저장된다라는 표현도 있는데 이는, 세션 식별자(sid)가 클라이언트에 저장되기 때문인 것으로 생각된다)

### what is Cookie?
- 쿠키는 클라이언트 컴퓨터에 저장되는 최대 4KB의 크기를 가지는 작은 텍스트 기반 파일이며, 해당 클라이언트의 브라우저에서만 접근할 수 있다.
- 클라이언트가 어떤 웹사이트에 처음으로 접속하면 웹사이트는 쿠키에 많은 정보를 담아서 클라이언트의 컴퓨터로 전송한다. 그리고 클라이언트가 웹사이트를 이용하는 동안 일어나는 모든 활동을 추적한다.
- 쿠키는 누구나 읽을 수 있는 텍스트 기반 파일이 클라이언트 측에 저장되는 것이기 때문에 상대적으로 안전하지 않다.
- 쿠키는 만료 시점을 쿠키 저장시에 설정하게 되며, 클라이언트는 쿠키 옵션을 꺼버리거나 삭제할 수도 있다.
- 쿠키는 같은 도메인에서만 유효하다.

### why use Cookie?
- http는 상태 비저장 프로토콜로 전송되는 요청들은 모두 독립적이며, 서버에 클라이언트에 관한 정보를 따로 저장하지 않는다. 그래서 클라이언트의 정보가 필요할 경우에 쿠키나 세션을 사용하게 되는 것.
- 세션과 별개로 쿠키를 사용하는 이유 중 하나는, 세션은 서버 자원을 쓰기 때문에 모든 정보를 세션에 저장할 경우 관련해서 부하가 일어날 수 있기 때문이라고 한다.
- 쿠키의 주요 목적
	- 세션 관리 : 사용자의 로그인 상태와 같이 서버가 기억해야 하는 사용자의 세션 관련한 세부 정보 저장
	- 개인화 : 사용자별 기본적인 설정들
	- 추적 : 사용자의 행동을 기록하고 분석하기

### what is Session?
- 세션 또한 상태를 저장하지 않는 http의 특성을 보완하기 위해 사용된다. 만약 세션이 없다면, 사용자가 장바구니에 원하는 물건을 담은 뒤에, 다른 물건을 보러 페이지를 이동시키면 장바구니의 내용이 계속 저장되지 않고 날아가 버릴 것!
- 세션은 클라이언트의 정보를 계속 유지하며 활용할 수 있도록 서버 측에 저장하는 방법이다.
- 간단하게 말하자면 세션은 한 사용자가 접속해서 요청과 응답을 반복하며 활동을 하는 기간이며, 이 기간동안은 이 사용자의 정보를 계속 가지고 있는 것이다. 데이터의 단위 같은 개념
- 세션은 사용자의 로그인이 이루어지면 세션 변수에 이에 관한 정보를 저장해 두고, 다음 요청이 들어왔을 때 서버가 이 세션 변수를 확인하여 사용자를 인식하게 된다.
- 이 세션 기간은 홈페이지나 프로그램에 엑세스 할 때 시작되어서 이를 종료하거나, 컴퓨터를 종료할 때 종료된다. 혹은 세션 타임아웃 설정을 통해서도 종료시킬 수 있다.

### why use Session?
- 민감한 정보들을 상대적으로 안전한 서버에 안전하게 저장하기 위해서 사용한다.
- 쿠키를 지원하지 않는 웹 브라우저인 경우 쿠키 대신 세션을 사용할 수 있다.

### how session work? [📑](https://medium.com/@hendelRamzy/how-session-and-cookies-works-640fb3f349d1)
- 사용자가 웹사이트에 로그인하면 세션이 생성되고, 이 세션에서는 키-값 형태의 세션 변수가 설정된다.
- 생성된 세션은 고유 ID를 가지게 되며, 생성된 세션 ID가 사용자의 브라우저에 쿠키로 저장되고, 세션 데이터는 서버에 저장된다.
- 이후 사용자가 서버로 요청을 보내게 되면, 서버는 사용자의 쿠키에서 세션 ID를 검색해서 해당 데이터를 찾는다.

### 세션 구현 방식 알아보기
[📑](https://blog.naver.com/wharup/223281848620)
#### Sticky Session
- 사용자별로 전담 WAS를 배정하는 방식
- 특정 WAS가 담당하는 해당 사용자의 모든 요청을 처리한다.
- 각자 자신에게 배정된 사용자만의 정보를 알고 있으면 되고, 다른 WAS와 정보를 공유할 필요가 없으니 구현이 간단
- WAS의 부하 분배가 어려워지고, 담당 중인 사용자가 모두 연결을 완료할 때까지 해당 WAS 서버를 종료할 수 없음

- 서버의 스케일 인-아웃 상황을 가정해보자. 트래픽이 증가하여 새로운 WAS가 추가된다고 해도 스티키 세션 방식에서는 새로운 WAS에 기존 사용자들의 요청을 분산할 수 없다. 왜냐면 사용자 정보가 WAS에 귀속되어 있기 때문이다.
- 그리고 배포를 위해 서버를 종료해야 하는 경우 역시 마찬가지로 자연스럽게 종료하고 다시 올리기 어렵다. 해당 WAS가 처리중인 사용자가 없을 때까지 기다려야 하기 때문

→ 자유로운 스케일 인-아웃이 어렵고 다양한 배포 방식의 적용 또한 어려움.

#### Session Clustering
- 모든 WAS가 모든 사용자의 로그인 상태 정보를 동기화해서 가진다.
- 그렇기 때문에 처리 속도는 빠름
- WAS의 수가 늘어나는 경우 동기화에 부담이 되는 문제

- 서버의 스케일 인-아웃 상황을 가정해보자. 증가되는 새로운 WAS에 기존 모든 사용자의 정보를 복사해서 넣어야 한다! 이는 동기화 부담이 심해지는 문제가 될 것
- 특히 클라우드 MSA 환경에서는 더더욱 그러함.
	- 물리 서버라면 브로드캐스팅을 활용하여 동기화 부담 줄이기 가능

#### Session Storage
- 로그인 상태 세션 정보를 외부의 보관소에 보관한다.
- 외부에 있는 정보 값을 읽고 쓰면서 사용해야 하기 때문에, 처리 속도가 저하되는 문제
- 따라서 세션 저장소는 안정적이고, 속도가 빠른 저장소를 사용하는 경우가 많다

- 3가지 방법 중 그나마 스케일 인-아웃 상황에 크게 영향받지 않는 구현 방법이다