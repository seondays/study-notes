# HTTP/1 vs HTTP/2 vs HTTP/3
[HTTP/1 vs HTTP/2 vs HTTP/3](https://dev.to/accreditly/http1-vs-http2-vs-http3-2k1c)과 [The Differences Between HTTP 1.1, HTTP/2 and HTTP/3](https://accreditly.io/articles/the-differences-between-http-11-http2-and-http3)
를 읽고 학습한 문서입니다.
## HTTP/1.1
1996년에 출시된 HTTP/1.0의 개정판으로 여러 가지 불편 사항이 개선되었으며, 중요 개선 사항들은 아래와 같다.
### Persistent connections
#### HTTP/1.0
- 요청에 대한 응답 이후 서버와 클라이언트간의 TCP 연결이 끊기기 때문에, 요청 시 마다 새로운 TCP 연결이 필요하다.
#### HTTP/1.1
- 요청 응답 연결이 일회성이 아니라, 한 번의 연결을 가지고 계속해서 연결된 채로 여러 번의 요청과 응답을 주고받을 수 있도록 하는 기능을 지원하도록 개선되었다.
- 잦은 연결과 종료 시 핸드셰이크 과정에서 오는 오버헤드가 감소하여 네트워크 성능이 개선되는 효과가 있다.
### Pipelining
#### HTTP/1.0
- 요청과 응답이 순차적으로 이루어진다. 따라서 앞 선 요청에 대한 응답이 되돌아온 후에 그 다음 요청에 대한 처리가 이루어진다.
- 따라서 이전 요청이 완료되지 않으면 그 다음 요청을 보낼 수 없었다.
#### HTTP/1.1
- 파이프라이닝 기능의 지원으로 클라이언트는 응답이 오는 것을 기다리지 않고 연속적으로 요청을 보낼 수 있도록 개선
- 다만 여전히 서버가 응답하는 순서는 요청을 받은 순차적으로 진행된다. 첫 번째 요청의 응답이 지연되고 있다면 두 번째, 세 번째 요청의 응답도 지연된다. → `head-of-line blocking` 문제
### Chunked transfer encoding
#### HTTP/1.0
- 요청받은 리소스의 전체 크기를 먼저 알아야 응답을 전송할 수 있다.
- 따라서 서버는 전체 응답을 생성한 다음 클라이언트로 응답하게 된다.
#### HTTP/1.1
- 청크 전송 인코딩의 도입으로, 전체 크기를 알 수 없는 상태에서도 데이터를 청크 단위로 나눠서 전송이 가능하도록 개선됨
- 따라서 `Content-Length` 헤더를 사용하지 않고, `Transfer-Encoding: chunked`와 같은 식으로 표시하여 사용한다.
### Cache control mechanisms
#### HTTP/1.0
- 캐시 기능을 위한 방법이 다양하지 않았고 기본적인 방법만 제공되었다.
#### HTTP/1.1
- `Cache-Control` 헤더가 도입되면서 세밀한 방법으로 캐시 동작을 제어할 수 있도록 개선됨
### Host header
>**Host 헤더란?**
> - 서버의 호스트명과 포트번호를 명시해주는 헤더. 웹 서버에게 어떤 웹사이트의 자원을 요청하는지 알려 준다.
> - 즉 같은 ip로 요청을 한다고 해도, 해당 헤더를 가지고 어떤 웹사이트에게 요청하는 것인지 정확하게 알 수 있다.
#### HTTP/1.0
- 호스트 헤더가 필수적이지 않아, 가상 호스팅 환경에서 문제가 될 수 있었다.
- 하나의 ip 주소에 하나의 도메인
#### HTTP/1.1
- 호스트 헤더가 필수로 변경되었으며 가상 호스팅 환경에서 명확히 호스트 정보를 표기할 수 있게 되었다.
- 하나의 ip 주소에 여러 도메인이 호스팅되더라도 해당 헤더를 통해 문제 없이 사용 가능 → ip 주소 절약 가능
## HTTP/2
앞서 알아본 것처럼 HTTP/1.1에는 `head-of-line` 문제, 캐시 제어 문제 외에도 우선순위 지정 문제, 텍스트 기반 등과 같은 문제가 있었고, 이러한 문제들은 성능에 큰 영향을 미치게 된다.

2015년에 출시된 HTTP/2는 기존 어플리케이션들과의 호환성을 유지하면서, 1.1의 문제점들을 개선하기 위한 버전이다.
### Binary framing layer
- 요청과 응답이 텍스트 기반이었던 HTTP/1번대와 달리, HTTP/2에서는 바이너리 기반으로 통신을 하도록 변경되었다.
- 2에서 모든 통신은 정해진 binary frame 구조에 맞게 인코딩된 후 분할되어 전달된다. 때문에 파싱 속도가 빠르고 데이터 크기도 작다.
### Multiplexing
- 멀티플렉싱을 통해 하나의 연결에서 여러 요청과 응답을 동시에 처리할 수 있게 되었다.
- 이를 통해 `head-of-line` 문제를 해결하고 네트워크 리소스를 효율적으로 사용할 수 있다.
    - 기존 1.1에서도 keep-alive를 통해 하나의 연결에서 끊기지 않고 데이터를 주고 받을 수 있었지만, 동시에 병렬적으로 처리할 수는 없었다. 순서대로 하나가 끝나고 하나가 시작되는 식으로 작동했음
    - 이와 다르게 멀티플렉싱은 동시에 처리할 수 있게 되었다는 것이 중요 차이점이다.
    - 하지만 TCP 기반이기 때문에 해당 문제가 완전히 사라졌다고 보기는 어렵다.
        - 패킷이 중간에 손실 & 지연되면, 해당 패킷이 도착할 때까지 나머지 모든 패킷들이 기다려야 함
- 멀티플렉싱은 바이너리 프레임과 밀접한 관련을 가지는데, 해당 개념이 도입됨으로 인해서 데이터를 나누어서 독립적으로 전송할 수 있게 되었다.
    - 하나의 요청 메시지가 여러 개의 프레임으로 나눠지게 되어 이를 각각 독립적으로 전송할 수 있기 때문에 전송된 후 해당 스트림에서 전송받은 프레임을 조합해서 사용하기만 하면 된다. 따라서 서로 다른 요청들도 동시에 전송되어 처리하는 것이 가능해진다.

![image](https://github.com/user-attachments/assets/11c8bc05-c004-42b4-a2c6-b67bd6b2d121)

### Header compression
- HTTP/2는 HTTP 헤더를 HPACK 알고리즘을 이용해 압축하여 전송 데이터의 크기를 줄인다.
### Server push
- 클라이언트가 서버에 리소스를 명시적으로 요청하기 전에 미리 리소스를 전송하도록 하는 기능
- 예를 들어 특정 웹 페이지를 요청하는 경우, 내부에 이미지 태그가 있다고 하면 서버는 해당 이미지 리소스에 대한 명시적 요청 없이도 미리 리소스를 보낸다. (push)
- 이렇게 되면 요청 횟수가 줄어드므로 네트워크 왕복 횟수가 감소하고, 페이지를 로드하는 시간도 줄어드는 이점이 있다.
### Stream prioritization
- 멀티플렉싱으로 요청-응답을 주고받을 때 클라이언트는 요청마다 우선순위를 지정할 수 있다.
- 이를 통해 더 중요하고 우선순위가 높은 요청에 더 빠르게 응답할 수 있게 된다.
-----
HTTP/2는 TCP 위에서 동작하는 프로토콜이다. 이는 기존 HTTP/1.1과 동일한 전송 계층을 이용하는 것으로, 기존 인프라와 호환성을 가진다는 것에 장점이 있다. (물론 신뢰성과 같은 TCP의 장점 역시 가진다)

반면 지연 시간이 길고 손실이 많은 네트워크 상황에서는 TCP가 문제가 될 수 있다는 단점도 존재한다.
- TCP 패킷이 손실되거나 지연이 발생하면 스트림에 영향이 감 → 성능 저하
## HTTP/3
HTTP/3 역시 HTTP/2의 단점을 해결하고, 웹 성능을 향상시키기 위한 변경 사항들이 포함된 버전이다.

가장 큰 변화는 전송 계층에서 TCP가 아닌 UDP, 즉 `Quick UDP Internet Connections`의 약자인 QUIC 프로토콜이 도입되었다는 점이다. 이를 통해 더 짧은 지연 시간, 더 나은 성능을 제공하고자 했다.

QUIC 프로토콜은 다음와 같은 이점을 가진다.
### Built-in encryption
- TLS 1.3을 내부적으로 통합하여 사용하기 때문에 안전한 통신이 가능하다. (초기에 보안을 위한 1-RTT 핸드셰이크 작업 진행)
- 즉 모든 패킷이 전송 계층에서 암호화되어 전송된다.
### Reduced head-of-line blocking
-  TCP에서 패킷이 손실되는 경우 모든 스트림의 패킷이 대기해야 했던 것과 다르게, QUIC은 패킷 손실을 개별 스트림 수준에서 처리한다.
- 따라서 TCP 프로토콜에서 발생하는 `head-of-line` 문제를 더 줄일 수 있게 된다.
### Connection migration
- 클라이언트의 IP 주소가 변경되어도 클라이언트-서버 연결이 끊기지 않고 유지될 수 있도록 지원한다.
### 0-RTT connection establishment
- 이전에 방문한 서버에 다시 연결하는 경우 0-RTT 연결 설정을 지원한다.
- 즉 핸드셰이크 과정 없이 즉시 데이터를 전송할 수 있기 때문에 RTT 없이 연결이 가능해진다.
### Improved congestion control
- 향상된 혼잡 제어 메커니즘을 제공하여 성능을 개선할 수 있다.