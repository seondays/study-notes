# section2. 영속성 컨텍스트
영속성 컨텍스트란 엔티티를 영구 저장하는 환경이라는 의미로, 논리적인 개념이다. 우리는 `EntityMaanger`를 통해 이 영속성 컨텍스트에 접근하고 있는 것

## ✔︎ 엔티티의 생명 주기
JPA의 엔티티에는 생명 주기가 존재함
#### 비영속
JPA와 상관 없이 객체가 생성되어 있는 상태. 당연히 DB에도 들어갈 수 없다.
#### 영속
`persist()`를 통해 JPA의 관리 아래로 들어가며, 영속 상태가 된다.
- 아직 DB에 저장된 상태가 아님!
- 트랜잭션이 커밋될 때, 영속성 컨텍스트 내부에 있는 영속 상태의 엔티티들이 비로소 DB에 저장되는 것
#### 준영속
영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 상태 (`detach()`)
- 영속성 컨텍스트의 1차 캐시에 들어가 있지 않으며, JPA가 관리하지 않는 상태이다.
- 따라서 준영속 상태 엔티티들은 더티 체킹과 같은 기능들이 작동하지 않음
#### 삭제
객체를 삭제한 상태 (`remove()`)

## ✔︎ 영속성 컨텍스트의 이점
### 1차 캐시
- 영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다.
    - 예를 들어보자면 `persist`를 이용해서 엔티티를 1차 캐시에 저장하고, 그 다음에 바로 `em.find`로 조회할 경우 DB가 1차 캐시에서 가져오게 된다.
    - 물론 1차 캐시에 해당되는 값이 없으면 DB에서 조회를 한다.
- 그런데 사실 트랜잭션이 끝나면 `EntityMaanger`가 사라지고 영속성 컨텍스트가 날아가기 때문에, 1차 캐시가 엄청난 성능적 이점이 있는 것은 아님
### 영속 엔티티의 동일성 보장
- 영속 엔티티는 동일성이 보장된다.
- 1차 캐시가 존재하기 때문에, 동일 트랜잭션 내에서는 항상 같은 객체를 읽어오게 된다.
### 트랜잭션을 지원하는 쓰기 지연
- 엔티티 등록 시 트랜잭션을 지원하는 쓰기 지연이 가능하다.
    - persist를 해도 바로 쿼리가 실행되는 것이 아니라, 영속성 컨텍스트 내부의 `쓰기 지연 sql 저장소`에 쿼리문을 쌓아 둔다.
    - 트랜잭션이 끝날 때, 모아 둔 쿼리가 날아간다. (flush)
- 버퍼링 개념으로 DB와의 통신 횟수가 줄어들기 때문에 성능상 이점
### 엔티티 변경 감지 (더티 체킹)
- 영속성 컨텍스트는 지금 영속 상태인 엔티티의 조회 시 상태 스냅샷을 가지고 있다.
    - 그래서 값이 바뀌면 해당 스냅샷과 비교해서 바뀐 값이 DB에 실제로 업데이트가 되게 된다.
        - flush 호출 → 스냅샷과 엔티티 비교 → 변경된 게 있으면 쓰기 지연 저장소에 업데이트 쿼리 생성 → flush → 커밋으로 DB에 저장

## ✔︎ flush ?
영속성 컨텍스트의 변경 내용을 DB에 반영하는 작업 (동기화)
- 커밋이랑 동일한 것 아님
- 더티체킹, update 쿼리 등록, 지금까지 모아두었던 쿼리들을 DB에 반영
- flush가 호출된다고 해서 1차 캐시가 사라지는 것은 아니다
### 플러시를 호출하는 방법
- em.flush() 를 이용해서 직접 호출
- 트랜잭션 커밋을 하면 자동으로 호출
- jpql 쿼리 실행할 경우 자동으로 호출
### 왜 JPQL을 실행할 때 플러시가 자동으로 실행이 되도록 되어 있나?
jpal은 작성된 쿼리가 그냥 네이티브 쿼리로 날아가게 된다.

그런데 만약 쿼리가 날아갈 때, 기존에 아직 플러시 되지 않아 영속성 컨텍스트에만 남아 있고 DB에 반영되지 않은 내용들이 있다면 동기화 문제로 제대로 된 결과가 나오지 않을 수 있다.

따라서 이러한 문제를 방지하기 위해 JPQL이 실행될 때 플러시가 먼저 자동으로 실행되도록 되어 있는 것