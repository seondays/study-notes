# 관련 용어 정리
논리적 계층이 있는 구조
- **노드(node), 정점(vetext)** : 트리를 구성하는 항목
- **간선** : 노드와 노드를 연결하는 항목
- **부모노드** : 특정 노드의 바로 상위에 위치한 노드. 각 노드는 하나의 부모를 가질 수 있다
- **자식노드** : 특정 노드의 바로 하위에 위치한 노드
- **루트** : 부모가 없는 노드. 최상위 노드
- **진입차수** :특정 노드로 들어오는 간선의 개수
	- 루트를 제외한 모든 노드의 진입차수는 1이다
	- 2인 이상은 그래프가 됨
- **진출차수** : 특정 노드에서 나가는 간선의 개수
- **잎** : 자신의 서브트리가 없는 트리. 트리의 맨 하위에 위치
- **내부노드** : 루트와 잎이 아닌 노드
- **형제** : 특정 노드와 같은 부모를 가지는 노드
- **트리의 레벨** : 루트로부터 특정 노드까지 이어진 경로의 길이
# 이진 트리 (Binary Tree)
트리에 속한 모든 노드의 차수가 2 이하인 트리
### 이진 트리의 종류
#### 전 이진 트리 (Full Binary Tree)
이진 트리에서 모든 노드가 0 또는 2개의 자식을 가지는 트리
#### 포화 이진 트리 (Perfect Binary Tree)
이진 트리에서 모든 레벨이 허용되는 최대 노드의 개수를 가지는 트리
- 모든 내부 노드는 2개의 자식을 가진다
- 모든 잎의 레벨이 동일하다
- 루트레벨이 0이고 높이가 k인 포화이진트리의 노드 개수는 2^k - 1
#### 완전 이진 트리 (Complete Binary Tree)
트리의 높이가 k인 이진 트리에서 트리의 k-2 까지 모두 최대로 채우고, 마지막 k-1 레벨에서 왼쪽부터 오른쪽으로 채워져 있는 트리
### 이진 트리의 구현
#### 배열에 저장하기
- 트리가 포화 이진 트리 혹은 완전 이진 트리인 경우 연속된 배열이 낭비되는 공간이 없어 효율적
- 해당 트리들의 경우 인덱스 계산하기도 쉽다
- 하지만 해당 이진 트리가 아니라면 낭비가 심해진다 (예를 들어 경사 이진 트리 등)
#### 연결 리스트에 저장하기
따라서 보통 이진 트리는 연결 리스트로 구현
- 왼쪽 서브트리 포인터, 오른쪽 서브트리 포인터, 데이터로 노드가 구성됨
### 이진 트리의 연산
#### 순회
- 전위순회(PLR)
- 중위순회(LPR)
- 후위순회(LRP)
#### 일반 트리 → 이진 트리 변환
1. 주어진 트리에 대하여 각 노드의 형제들을 연결
2. 각 노드에 대하여 가장 왼쪽 링크만 남기고 모두 제거
	1. 루트 노드는 반드시 왼쪽 자식 하나만 가지도록 하기
3. 첫 번째 자식 노드를 제외한 다른 형제들을 첫 번째 자식 노드의 오른쪽 자식으로 설정
## 스레드 트리
이진 트리를 효율적으로 순회하기 위한 자료구조. 정해진 순회 방법에 따른 방문 순서를 유지하는 스레드 포인터가 존재한다
따로 스레드 포인터를 노드에 포함시킬 수도 있지만, 그렇게 추가하지 않고 기존 노드 구조에서 잎 노드의 NULL인 필드를 사용할 수 있다.
- 이진 트리에서는 항상 N + 1개의 NULL 포인터가 존재한다는 것을 활용하는 방법이다
- 단, 잎 노드에서 사용되는 값이 스레드 포인터인지, 아니면 실제로 연결되어 있는 간선인지를 식별하기 위해 따로 플래그 변수를 사용해야 한다.
## 힙
힙은 우선순위 큐를 트리로 구현한 것으로, 우선순위 큐의 한 종류이다.
- 힙은 `완전 이진 트리`이다
- 동시에 힙은 다음과 같은 조건 중 하나를 만족해야 함
	- **최대 힙** : 부모 노드의 키가 자식보다 항상 크거나 같음
	- **최소 힙** : 부모 노드의 키가 자식보다 항상 작거나 같음
- 힙은 완전 이진 트리 → 따라서 내부적으로 배열로 구현한다
- 왼쪽 자식 노드의 위치가 `i` 라면, 오른쪽 자식 노드의 위치는 `i + 1`, 그리고 부모 노드의 위치는 `i / 2` 로 간단하게 계산 가능
- 인덱스 계산을 쉽게 하기 위해 0부터가 아닌 배열의 1부터 사용한다
## 선택 트리
정렬된 리스트를 가지고 합병 정렬하는데 사용되는 선택 트리로, 승자 트리와 패자 트리 두 가지 종류가 있다
### 승자 트리
1. 정렬된 리스트의 값들을 트리의 리프 노드에 넣는다
2. 형제 노드끼리 비교를 진행한다
3. 승리한 노드를 부모 노드로 올린다
4. 이를 반복하여 루트에 가장 작은 값이 오게 되면, 1회전 완료
	1. 최종 승자의 값이 있던 리프는, 해당 리스트의 그 다음 값으로 채운다
5. 2회전부터는 최종 승자가 타고 올라온 루트만 비교하면서 올라오면 된다
	1. 즉 비교 횟수가 2회전부터는 줄어드는 것 (O(nlogk))
### 패자 트리
패자 트리는 승자 트리와는 다르게 최상위 노드를 하나 더 사용한다. 이 0번 노드에 최종 승리자가 저장된다
1. 정렬된 리스트의 값들을 트리의 리프 노드에 넣는다
2. 형제 노드끼리 비교를 진행한다
3. 부모 노드에 패자 노드를 올린다
4. 승자를 부모의 부모 노드에서 다시 경쟁한다
5. 이렇게 되면 루트에는 최종 패자(2등)가 저장된다

패자 트리를 사용하게 되면, 경쟁하는 형제 노드를 찾기 위해 부모를 거쳐서 내려가는 추가적인 연산을 하지 않아도 되는 장점이 있다