## Concurrency control
- 많은 수의 사용자가 동시에 어플리케이션에 액세스하는 상황에서 각 사용자의 작업 결과가 서로 상충하는 것은 불가피
- 따라서 이러한 동시 트랜잭션 환경에서도 일관적인 결과를 유지하기 위해서 동시성 제어가 필요한데, 이를 위한 다양한 방법 중 하나가 바로 락을 사용하는 것이다.
## Lock 이란?
> 데이터베이스에서 동시에 여러 작업이 실행될 때 결과의 무결성과 일관성을 유지하기 위해 사용하는 매커니즘 → 하나의 트랜잭션만 특정 리소스를 수정 혹은 액세스하도록 하는 방식으로 작동한다.

## 잠금 구현 매커니즘
락은 크게 `공유 락`과 `배타 락`의 두 가지 유형으로 나뉜다.
<font color="#a5a5a5">(락의 대상이 되는 테이블, 레코드 페이지 등등은 리소스로 통칭하고, 락을 획득하는 주체는 트랜잭션이나 프로세스 스레드 등등이 있으나 대표적으로 트랜잭션을 가지고 설명하려고 한다)</font>
### 공유 락(Shared lock, Read lock)
- 공유 락을 사용하는 경우 대상 리소스에 읽기 전용 잠금을 건다.
- 따라서 공유 락을 읽기 락이라고도 함
- 여러 트랜젝션에서 동일한 리소스에 대한 공유 락을 획득하여 리소스를 읽을 수 있다.
- 대신 다른 어떤 트랜잭션도 공유 락이 걸려있는 해당 리소스를 수정할 수 없다.
	- 즉 리소스 업데이트를 위해서는 공유 락이 걸려있지 않아야 한다. (이후 배타락을 획득 후 수정)
### 배타 락(Exclusive lock, Write lock)
- 배타 락은 리소스를 잠그고 배타 락을 획득한 트랜잭션이 해당 리소스를 수정할 수 있도록 한다.
- 따라서 배타 락을 쓰기 락이라고도 함
- 오직 하나의 트랜잭션만 특정 리소스에 대해 배타 락을 획득할 수 있다.
- 배타 락이 걸려있는 리소스에 접근하기 위해, 락을 획득하지 못한 다른 트랜잭션들은 기다려야 한다.
- 락이 해제되어야만 기다리던 트랜잭션들이 다시 배타 락을 획득할 수 있다.

공유 락이 걸려있는 리소스는 배타 락을 동시에 획득할 수 없으며, 반대의 경우도 마찬가지이다.
## 동시성 제어를 위한 전략
동시성 제어를 위해 세울 수 있는 전략에는 두 가지 방법이 있다.
### 낙관적 락(Optimistic lock)
- 동시성 문제가 거의 발생하지 않을 것이라고 낙관적으로 바라보는 관점
	- low data contention
- 따라서 병렬적으로 여러 트랜잭션이 리소스에 대해 동시에 접근해서 읽기/쓰기 할 수 있다.
- 다만 그 중 하나의 트랜잭션이 해당 리소스에 대해 변경을 하고 커밋하게 된다면, 다른 트랜잭션들에게 문제가 발생했음을 알리고(예외 발생) 트랜잭션 작업을 변경된 리소스를 대상으로 다시 시작하도록 한다. (트랜잭션 롤백)
- 애초부터 막지 않고 자유롭게 읽기/쓰기를 하되, 충돌이 발생하면 사후에 처리한다는 관점이기 때문에 높은 동시성을 지닌다.
- 물리적인 락 적용 x → 주로 버전 관리를 이용하여 낙관적 락을 구현한다.
### 비관적 락(Pessimistic lock)
- 동시성 문제가 반드시 발생한다는 관점
- 무조건 동시성 문제는 발생하기 때문에, 이를 방지하기 위해 리소스에 접근하면서 무조건 락을 건다.
	- 단 이때 걸리는 락은 어떤 작업을 하느냐에 따라 공유 락일수도, 배타 락일수도 있음
- 한 트랜잭션이 쓰기를 위해 리소스에 접근하여 배타 락이 걸려있는 동안 다른 트랜잭션은 해당 리소스를 읽을 수도, 수정할 수도 없다.
	- 즉, 락이 걸린 리소스에 대해 다른 트랜잭션이 공유 락, 배타 락 둘 다 걸 수 없고 기다려야 함
- 한 트랜잭션이 읽기를 위해 리소스에 접근하면 공유 락이 무조건 걸린다. 이 경우 읽기를 원하는 다른 트랜잭션도 리소스에 접근하여 공유 락을 획득할 수 있다.
	- 읽기 동시에 가능
	- 다만 쓰기를 원하는 트랜잭션이 있는 경우 배타 락을 걸기 위해 모든 공유 락이 해제될 때까지 대기해야 한다.
- 높은 일관성을 보장할 수 있는 방법이지만, 동시성 처리의 효율은 떨어지게 된다.

## 상황에 따른 락 전략 선택 중요
낙관적 락을 선택할지 비관적 락을 선택할지는 당연히 상황에 따라 달라진다.
- 예를 들어 여러 단계를 거치는 대규모 트랜잭션이 주로 일어나는 상황인 경우 비관적 락을 사용한다?
	- 락을 오래 유지하게 되어 대기가 길어지게 되고, 혹여나 중간에 트랜잭션이 실패하게 된다면 시간 낭비가 심하다. (작업의 실패율이 높은 환경인가? 도 고려할 점)
	- 이런 상황에서 낙관적 락을 사용하는 것이 모든 트랜잭션이 기다리지 않고 리소스들에 접근할 수 있어 더 적합할 수 있다.

### 실제로는 배타 락을 걸어도 다른 트랜잭션에서 조회가 가능하던데 이유가 뭘까?
일반적인 경우 DB에서는 배타 락이 걸려있는 리소스를 다른 트랜잭션에서 조회하는 것이 가능하며, 이를 가능하게 하기 위해 MVCC를 활용한다.

MVCC는 잠금을 사용하지 않는 일관된 읽기를 제공하며, 이를 위해 데이터의 스냅샷을 만들어 활용한다.
즉, 하나의 레코드에 대해 여러 버전의 스냅샷이 존재하고, 각 상황별로 트랜잭션마다 참조하는 스냅샷의 버전이 달라진다. 특히 InnoDB에서는 언두 로그를 이용해 이 기능을 구현한다.

1. A 트랜잭션이 1번 레코드에 대해 배타 락을 걸고 수정 작업을 진행한다.
2. B 트랜잭션이 1번 레코드에 대해 읽기 작업을 시도한다.
3. 이 때 읽기를 위한 공유 락을 거는 대신 언두 로그에 저장되어 있는 1번 레코드의 수정 이전 스냅샷을 대상으로 읽기 작업이 진행된다.

이러한 과정을 통해 읽기 락을 걸지 않고도 조회가 가능하게 된다.