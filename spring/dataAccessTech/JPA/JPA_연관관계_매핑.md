# 연관관계 매핑 정리
1. 다중성
2. 단방향, 양방향
    - 객체 양방향 관계에서 연관관계의 주인은 many 쪽으로 설정하는 것이 권장된다.
    - 실제 DB 테이블에서 외래키가 many 쪽에 지정되기 때문에, 객체에서도 many 쪽을 주인으로 설정해서 동일한 객체-테이블이
      함께 업데이트 되도록 하는 쪽이 이해하기도 쉽고 실제 동작에서도 합리적이다.
    - 만약 반대로 one 쪽이 주인이 된다면, 관리해야 하는 외래키가 자신의 테이블에 없기 때문에 내용의 변경을 위해
      실제 외래키가 있는 다른 테이블에서 추가적인 쿼리가 발생하게 된다.
3. 연관관계의 주인
    - @JoinColumn을 가진 쪽이 연관관계의 주인이 된다.
    - JPA는 연관관계의 주인만 외래키를 관리할 수 있다. 해당 어노테이션이 있다면 테이블이 생성될 때 외래키가 생성된다.
    - 반대 입장에 있는 엔티티는 mappedBy 속성을 사용해서 연관관계의 주인의 필드 이름을 값으로 입력한다.
    - 반대 입장에 있는 엔티티는 단순 조회가 가능하다.
## 다대다
### 다대일 단방향
- Member(n), Team(1)
- many에 외래키 컬럼이 들어가 있다. 따라서 Member에서 Team을 조회할 수 있지만, 반대는 불가능하다.

### 다대일 양방향
- Member(n), Team(1)
- 양방향 연관관계는 항상 서로를 참조하게 된다.
    - @JoinColumn과 mappedBy 를 사용하여 서로를 참조한다.
    - 다만 무한루프나 순환참조에 유의할 것
- 일대다 관계는 엔티티를 하나 이상 참조할 수 있으므로, 컬렉션을 이용하게 된다.
- 예를 들어 Team은 Member의 `List`를 가지게 된다.

### 일대다 단방향
- Team(1), Member(n)
- 팀이 회원들을 참조하고(List<Member>) 회원은 팀을 참조하지 않는다.
- 이 매핑은 반대쪽 테이블에 있는 외래 키를 관리하게 된다.
    - 일대다 관계에서 외래 키는 항상 many 테이블에 있지만, 지금은 many 쪽에 참조하는 필드가 없다.
    - 그래서 팀이 회원을 관리하는 모습이 나타난다.
- 일대다 단방향 관계에서 꼭 @JoinColumn을 명시해 주지 않으면 중간 테이블이 생기게 된다.
- 단점은 연관관계 처리 시에 Member 쪽에 update 쿼리가 생기게 된다.
- 그래서 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자!

### 일대다 양방향
- 일대다 관계에서 양방향이 설정되는 경우는, 외래 키가 있는 테이블과 매핑된 객체에도 참조가 추가된다는 것이다.
- 따라서 양쪽에서 다 외래키를 관리하는 모양이 되므로 개념적으로 오류가 있다.
- MenyToOne에는 mapped가 없기 때문에 사용할 수가 없고, 굳이 해주고자 한다면 둘다 JoinColumn을 달아준 다음에 many 쪽에 읽기 전용으로 설정해주면.. 되지만 이렇게 할 바에 다대일 양방향을 사용하는 것이 바람직하다.

## 일대일
일대일 관계는 두 테이블 중 어느 곳이나 외래 키를 넣을 수 있다. 따라서 주 테이블과 대상 테이블 중에 어느 테이블에 외래 키를 넣을지를 결정해야만 한다.  
(여기서의 주 테이블이라는 것은 더 자주 사용되는 그런 테이블)

어느 쪽에 외래 키를 넣을지는 고려 사항들이 있는데 주 테이블 여부, 추후 변경 가능성 등이 있다.

### 주 테이블에 외래 키
- **Member**(주), Locker(대상)
- 단방향인 경우 Member에 외래 키가 있고, 양방향인 경우 Locker에 mappedBy를 추가해 조회용으로 만들어 준다.
- 외래 키가 주 테이블에 있기 때문에, Member만 조회해도 Locker 값이 있는지 없는지를 확인할 수 있다.

### 대상 테이블에 외래 키
- Member(주), **Locker**(대상)
- 대상 테이블에 외래 키가 설정된다면, 만약 일대다 관계로 변경될 경우 따로 큰 수정을 할 필요가 없는 것이 장점
- 하지만 Member를 가져올 때 Locker의 여부(null인지?)를 무조건 상대 테이블을 확인해야만 알 수 있기 때문에 즉시로딩으로만 작동한다.
> 그렇다면 일대다 단방향 매핑도 본인 테이블이 아닌 FK가 있는 상대방 테이블을 확인해야 존재 여부를 확인할 수 있는데 왜 여기서는 지연로딩이 가능할까?  
> &rarr; 일대다 단방향인 경우 해당 필드의 타입을 컬랙션으로 가지고 있기 때문에, 일대일과는 다르게 프록시 컬렉션으로 대체되게 되고 이는 빈 컬렉션처럼 동작하여 지연로딩이 가능하다고 한다.  
> 하지만 대부분의 JPA 구현체들은 일대일처럼 단일 객체 프록시가 만들어지는 경우에 null인지 아닌지를 확인해야 하도록 되어 있다고 한다. 따라서 나중에 사용할 때 불러오는 지연로딩이 작동하지 않는 것

### 다대다
- 중간 테이블을 만들고 다대다 관계를 구현할 수 있지만, 이렇게 할 경우 중간 테이블에는 정보(칼럼)를 추가적으로 저장할 수 없게 된다.
- 따라서 다대다 관계는 중간 테이블과 다대일, 일대다 관계 2개로 나누는 것이 낫다.
- 이런 경우 기본 키로 복합 키가 사용된다면, 중간에 식별자 클래스(Serializable)를 사용해서 복합 키를 식별하도록 해주어야 한다.
- 복합 키를 사용하지 않고 새로운 기본 키를 사용할 수도 있다.
    - Long으로 키를 자동 생성해서 사용하는 것
- 다대다 관계를 풀어내기 위해서는 연결 테이블을 위해 식별자를 어떻게 구성할지 선택이 필요하다
    - 식별 관계 → 부모에게서 키를 받아와서 복합 키를 만들고, 해당 키를 기본 키로 사용하는 것
    - 비식별 관계 → 부모에게서 받아온 키는 외래키로만 사용하고, 기본 키는 다른 키로 사용하는 것