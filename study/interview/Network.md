# 네트워크 면접 스터디 준비

## 1. 쿠키와 세션의 차이?
쿠키와 세션은 둘 다 웹에서 클라이언트와 서버 사이에서 상태를 유지하고 정보를 저장하기 위한 기술이지만 이 상태 정보를 쿠키는 클라이언트 측에, 세션은 서버 측에 저장한다는 차이가 있습니다. 따라서 보안 측면에서 쿠키보다는 상대적으로 서버에서 관리되는 세션이 보안성이 높다고 할 수 있습니다.

저장 위치 뿐 아니라 저장되는 상태 정보의 내용에도 차이가 있는데, 쿠키는 상태정보의 내용이 담기는 반면 세션은 직접적인 상태정보의 내용이 아닌 세션 식별값을 저장합니다.

이러한 차이로 인해 간단한 정보를 저장하는 경우는 쿠키가, 상대적으로 민감한 정보는 세션을 사용하는 것이 일반적입니다.

#### 💫 쿠키 사용 시 보안성을 높이기 위해 어떠한 조치들을 취할 수 있나요?
쿠키 사용 시 보안성 문제는 주로 쿠키를 탈취당하는 것에서 발생합니다. 따라서 HttpOnly를 설정하여 쿠키에 접근하여 조작할 수 없도록 하고, Secure를 설정하여 HTTPS 환경에서만 쿠키가 전달되도록 하는 설정이 필요합니다.

### 1-1. 세션 방식의 로그인 과정에 대해 설명해 주세요.
먼저 사용자가 로그인 요청을 보내고 로그인에 성공하면, 서버는 해당 사용자를 식별할 수 있는 식별값인 세션 ID를 만들어서 사용자의 정보와 매핑하여 서버측에 저장합니다.

그리고 동시에 저장한 세션 ID값을 클라이언트로 반환합니다. 클라이언트는 이후 인증이 필요한 리소스에 접근할 때마다 해당 세션 ID를 포함하여 서버로 요청을 합니다.

서버는 해당 요청을 받아 세션 스토리지에 해당 세션 ID가 있는지 확인합니다. 이 정보를 기반으로 지금 요청을 보낸 사용자가 어떤 사용자인지를 알 수 있게 됩니다.

### 1-2. HTTP의 특성인 Stateless에 대해 설명해 주세요.
stateless란 서버가 클라이언트의 모든 요청을 독립적인 개별의 요청으로 받아들이는 것입니다. 즉, 서버는 클라이언트의 이전 요청의 내용을 기억하지 않으며, 이전 요청들은 그 다음에 들어오는 다른 요청들에 영향을 주지 않습니다.

### 1-3. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
네, Stateless의 관점에서 보면 서버 측에 상태 정보를 저장하는 세션 방식은 Stateless과 충돌합니다.

하지만 웹 서비스에서 사용자를 식별하고 기억하여 맞춤형 서비스를 제공하는 것은 여러 측면에서 중요한 부분입니다. 이러한 요구사항 때문에 세션 방식이 사용되고 있으며, 이는 설계에서 트레이드오프를 감수하는 것이라고 생각합니다.

이러한 문제를 해결하기 위해 등장한 개념이 JWT입니다. JWT는 클라이언트가 상태 정보를 포함한 토큰을 가지고 있으며, 이를 서버로 전달하여 인증을 수행합니다. 토큰은 서명되어 있어 위변조를 방지할 수 있고, 서버는 별도로 상태 정보를 저장할 필요가 없으므로 세션과 다르게 Stateless한 인증 방식이라고 할 수 있습니다.


- 무상태성에 관한 단점을 보완하는 한 가지 방법이라고 할 수 있다

### 1-4. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
세션은 서버에 상태정보가 저장되기 때문에, 서버 scale out에 대응하기 어려운 점이 있습니다. 따라서 여러 대의 서버가 있는 상황에서 여전히 세션 방식의 인증을 사용해야 한다면, 모든 서버가 접근 가능한 세션 스토리지를 따로 마련하여 클라이언트가 어떤 서버로 요청을 보내든간에 세션 정보를 확인할 수 있도록 설계가 필요할 것 같습니다.

- 여러 가지 방법 조사 (스티키 세션..)

## 2. HTTP 응답코드에 대해 설명해 주세요.
HTTP 응답코드란 서버로 보낸 요청에 대한 처리 결과 내용을 숫자로 나타낸 코드입니다. 특정 상황에 어떠한 코드를 사용하자고 미리 약속되어 있기 때문에, 해당 코드를 확인하면 리퀘스트 결과가 어떻게 처리되었는지 확인이 가능합니다.

200번대는 성공 응답, 300번대는 리다이렉션, 400번대는 클라이언트 에러, 500번대는 서버 에러와 같은 식으로 나누어져 있으며, 이를 통해 쉽고 빠르게 결과의 상태를 파악할 수 있습니다.

#### 💫 대표적으로 각 범주별로 응답코드를 몇 개만 설명해보세요
200번대에는 200 ok, 201 created
300번대에는 302 found
400번대에는 403 forbidden, 404 not found
500번대에는 500 Internal Server Error 등이 있습니다.

### 2-1. 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?
401 Unauthorized은 일반적으로 인증되지 않은 상태에서 인증이 필요한 리소스에 접근하거나, 인증이 실패하는 경우의 응답입니다. 예를 들면, 회원만 글쓰기 가능한 게시판에 비회원이 글쓰기를 요청하는 경우

403 Forbidden은 인증은 성공했으나, 접근하고자 하는 리소스에 관한 권한이 없어 접근 거부된 경우의 응답 코드입니다. 예를 들면, 게스트 권한의 회원이 어드민 페이지에 접근하고자 하는 경우

### 2-2. 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.
200 ok는 정상적으로 요청이 성공했음을 알려주는 응답입니다.
201 created는 좀더 특정한 상황인 리소스를 새로 생성하는 경우 정상적으로 생성되었다고 알려 주는 응답입니다. 주로 POST 요청에 대한 응답인 경우이며, 201 코드와 함께 응답 헤더 Location에 생성된 리소스에 접근할 수 있는 URL이 포함되는 것이 특징입니다.

### 2-3. 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요
응답코드 자체가 요청에 대한 상태값을 코드로 나타낸 것이다보니, 필요하다면 상호간의 미리 약속을 통해 커스텀 응답코드를 정의해서 사용하는 것도 가능하다고 생각합니다.

- 하지만 지양?

## 3. HTTP Method 에 대해 설명해 주세요.
HTTP 메서드는 클라이언트의 요청의 목적에 대해 설명하고, 요청이 성공하는 경우 예상되는 결과를 나타낼 수 있는 방법입니다.

예를 들면 GET인 경우는 서버 자원을 요청하며, 이에 대한 결과 응답으로는 요청한 서버 자원을 전달해 줄 것이라는 것을 예측할 수 있게 됩니다.

### 3-1. HTTP Method의 멱등성에 대해 설명해 주세요.
멱등성이란 동일한 요청을 여러번 보내더라도 그 결과가 달라지지 않고 서버의 상태도 동일하게 유지되는 성질을 의미합니다.

예를 들어 GET을 사용해서 조회를 하는 경우에는 여러 번 조회하더라도 그 결과가 동일하며, 서버 상태에도 영향을 미치지 않습니다.
반면 POST를 통해 새로운 자원을 생성하도록 하는 경우에는 해당 요청마다 자원이 생성되어 서버 상태에 여러 개의 자원이 생성될 수 있으므로, 멱등성이 없다고 할 수 있습니다.

### 3-2. GET과 POST의 차이는 무엇인가요?
GET은 서버에 있는 자원을 요청하는 데 사용하는 메서드로 주로 조회를 위해 사용되고, 전달할 정보가 있다면 쿼리 파라미터에 담아서 전달합니다. 멱등성이 있는 메서드입니다.

POST는 서버에 새로운 자원을 생성하도록 요청하는 데 사용하는 메서드로 전달할 정보는 body에 담아서 전달한다는 차이가 있습니다. 멱등성이 없는 메서드입니다.

### 3-3. POST와 PUT, PATCH의 차이는 무엇인가요?
POST 메서드는 기존에 서버에 존재하지 않는 새로운 자원을 생성하는 데 사용되는 반면, PUT과 PATCH는 존재하는 자원을 수정하는데에 주로 사용한다는 것에 차이가 있습니다.

PUT은 특정 자원을 전체 대체 시 사용되며, PATCH는 자원의 부분적인 수정이 필요할 때 사용된다는 차이가 있습니다.

### 3-4. HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
HTTP는 프로토콜로, 사용자들 간의 미리 약속된 형식을 지키는 것이 중요한 요소입니다.

일반적으로 GET은 조회를 위해 사용되며, body를 비워서 하는 요청으로 받아들여지고 있습니다. 따라서 이러한 보편적 형식과 어긋나는 방식으로 요청하는 경우 기존의 다른 서버들과 통신할 때 호환성 문제가 발생할 여지가 있고 혼돈을 줄 수 있습니다.

따라서 기술적으로 GET에 body를 넣을 수 있다고 해도 여전히 POST를 사용하는 것이라고 생각합니다.

## 4. HTTP에 대해 설명해 주세요.
HTTP는 월드 와이드 웹의 데이터 통신 기반이 되는 프로토콜로, 인터넷을 통해 웹 페이지와 같은 하이퍼텍스트 문서를 주고받는 방식을 정의합니다.

- connectionless와 stateless

### 공개키와 대칭키에 대해 설명해 주세요.
공개키와 대칭키는 암호화에서 사용되는 방법으로, 공개키는 암호화와 복호화에 두 개의 서로 다른 키를 사용하는 암호방식입니다. 제 3자 누구나 확인할 수 있는 키인 공개키로 전송할 내용을 암호화하고, 서버에서만 알고 있는 비밀키로 복호화하는 식으로 이루어져 있습니다.

반면 대칭키는 암호화와 복호화에 하나의 같은 키를 사용하는 암호방식입니다. 그렇기 때문에 키에 대한 보안이 중시되며 이 대칭키를 어떻게 안전하게 교환할 것인지가 중요한 부분입니다.

### 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
공인된 기관에서 발급된 인증서를 통해 클라이언트는 서버가 안전하고 신뢰할 수 있는 서버라는 것을 확인할 수 있기 때문입니다.

또 서버가 제공하는 공개키가 변조되지 않은 안전한 키임을 보장해주어 안전하게 암호화 통신을 할 수 있도록 해줍니다.

### SSL과 TLS의 차이는 무엇인가요?
SSL과 TLS는 보안 연결을 위한 암호화 프로토콜입니다. SSL은 초기 버전 프로토콜이고 TLS는 SSL의 단점들을 보완하여 나온 이후 버전입니다.

SSL 핸드셰이크 과정은 단계가 많고 속도가 느렸지만 TLS는 단계가 간소화되고 속도가 개선되었습니다.
또, MAC을 생성하는데 있어 SSL보다 TLS가 좀 더 보안성이 좋고 복잡한 알고리즘을 사용합니다.

최근에는 SSL은 사장되고 TLS가 사용되고 있습니다.

## 5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
소켓 통신은 OSI 7계층 중 4계층(전송 계층)에서 동작하는 저수준 통신입니다. 서버와 클라이언트가 TCP 또는 UDP로 직접 연결해 데이터를 주고받으며, 프로토콜 설계나 데이터 형식은 자유롭게 정의할 수 있습니다.

반면 웹소켓은 http의 실시간 양방향 통신을 위해 고안된 프로토콜입니다. HTTP에서는 요청을 하면 응답을 주는 방식으로 동작하기 때문에 서버가 클라이언트에게 먼저 통신할 수가 없어 양방향 통신이 불가능했기 때문에 이를 개선하기 위해 웹소켓이 등장하였습니다.

즉, 전송 계층에서 동작하는 소켓 통신과는 다르게 웹소켓은 이 저수준의 소켓 통신을 기반으로 하는 상위 수준의 프로토콜이며, 어플리케이션 계층에서 통신한다는 차이가 있습니다.

### 소켓과 포트의 차이가 무엇인가요?
포트는 통신을 위해 특정 프로세스를 식별할 수 있는 표지자의 역할을 하는 값입니다. 

반면 소켓은 TCP 계층에서 애플리케이션을 식별할 수 있도록 포트 번호에 바인딩되는 네트워크 상의 두 프로그램 간 양방향 통신의 엔드포인트입니다.

### 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
소켓의 포트 번호가 같은 경우가 있을 수 있습니다.

소켓을 식별할 때는 포트번호 뿐 아니라 연결된 클라이언트 Ip, 클라이언트 port, 서버 ip, 서버 port, 통신 프로토콜 종류와 같은 여러 값을 사용하기 때문에 포트번호가 같더라도 나머지 값이 다르다면 그것은 다른 소켓으로 식별될 수 있습니다. 따라서 포트 번호가 같은 경우도 존재할 수 있게 되는 것입니다. 

### 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
네 일반적으로 그렇습니다.

클라이언트의 요청이 들어오면, 서버의 listen 소켓은 실제 클라이언트와의 연결 작업을 담당할 소켓을 만들어 작업을 할당하기 때문입니다. 그렇기 때문에 요청이 들어올때마다 요청 작업을 하는 소켓들이 계속해서 생성되게 됩니다.

하지만 여러가지 요청 방식에 따라 달라집니다.

## 6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
가장 큰 차이점은 1.1에서 요청-응답이 순차적으로 처리되던 것과 다르게 , 2에서는 하나의 연결에서 여러 요청과 응답을 병렬적으로 동시에 처리할 수 있도록 하는 멀티플렉싱이 도입되었다는 것입니다. 이를 통해 2버전에서는 head-of-line 문제를 어느정도 해결할 수 있었습니다.

### 6-1. HOL Blocking 에 대해 설명해 주세요.
http 1 버전대에서는 요청과 응답이 순차적으로 이루어지기 때문에 이로 인해 앞선 요청이 완료되지 않으면 뒤에 오는 요청들도 대기해야 하는 HOL Blocking 문제가 발생합니다.

HTTP/2는 이 문제를 해결하기 위해 멀티플렉싱을 도입했으나, 여전히 TCP 기반에서 작동하기 때문에 패킷이 중간에 손실 & 지연되면, 해당 패킷이 도착할 때까지 나머지 모든 패킷들이 기다려야 하는 TCP HOL Blocking의 영향을 여전히 받게 됩니다.

### 6-2. HTTP/3.0의 주요 특징에 대해 설명해 주세요.
HTTP/3.0은 HTTP/2의 단점을 해결하고, 웹 성능을 향상시키기 위한 변경 사항들이 포함되었습니다.

가장 큰 변화는 전송 계층에서 TCP가 아닌 UDP, 즉 `Quick UDP Internet Connections`의 약자인 QUIC 프로토콜이 도입되었다는 것으로 이를 통해 더 짧은 지연 시간, 더 나은 성능을 제공하고자 했습니다.

## 7. TCP와 UDP의 차이에 대해 설명해 주세요.
TCP는 3-way-handshack를 통한 연결 지향적이고 신뢰성이 높은 프로토콜이며, UDP는 비연결성이 특징으로 빠르지만 신뢰성이 낮은 프로토콜입니다.

### Checksum이 무엇인가요?
체크섬이란 패킷의 내용에 오류가 있는지 없는지를 나타내기 위해 TCP, UDP 헤더에 존재하는 값입니다.

송신자가 계산 알고리즘을 통해 계산한 내용을 체크섬에 담아 송신하며, 수신자는 수신 데이터를 동일 알고리즘을 통해 검사하여 헤더의 체크섬 값과 같은지를 확인하는 식으로 오류를 검출할 수 있습니다.

### TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
TCP와 UDP 프로토콜 둘 다 헤더에 체크섬 값을 담아 오류를 비교하는 작업을 수행합니다.

### 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
아니오. 체크섬 값은 단지 패킷이 담고 있는 데이터에 문제가 있는지 오류를 발견하는 역할을 할 뿐이기 때문에, 이를 통해 오류를 정정할 수는 없습니다.

### TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
TCP 프로토콜에서는 3-way-handshake를 통해 송신자와 수신자가 서로 통신을 시작할 준비가 되었음을 확인하고, 이후 패킷을 주고 받을 때 TCP 헤더를 통해 아크 번호와 시퀀스 번호라는 정보를 서로 주고받게 됩니다.

시퀀스 번호는 쪼개져서 송신되는 데이터가 전체에서 몇 번째 바이트인지를 확인할 수 있도록 해주고, 수신 측이 해당 시퀀스 번호를 확인해서 문제 없이 도착한 것을 확인하면 몇 번째 바이트까지 받았다는 사실을 아크 번호를 이용해 송신 측에 알려 줍니다.

만일 패킷을 보냈는데도 이에 해당되는 아크 번호가 되돌아오지 않으면 오류가 발생했을 수 있다고 판단. 다시 패킷을 전송하게 됩니다. 이를 통해 오류나 누락 없이 패킷들을 전달할 수 있는 신뢰성을 보장하게 됩니다.

### TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
혼잡제어란 네트워크의 혼잡을 줄이기 위해 송신 측에서 패킷 전송 속도를 조절하는 것입니다. 

AIMD 방식은 매 RTT마다 송신 윈도우의 크기를 1씩 증가 시키다가 패킷 전송 실패나, 손실이 발생하면 송신 윈도우의 크기를 절반으로 만드는 방식이고,

슬로우스타트 방식은 작은 윈도우 크기로 시작하여 패킷을 하나씩 전송하다가 매 RTT마다 송신 윈도우의 크기를 두 배씩 증가 시킵니다. 그러다 패킷 손실과 같은 혼잡 현상이 발생하면  발생하면 윈도우 크기를 1로 만드는 방식 입니다.

일반적으로 이러한 여러 방식들을 적절하게 섞어서 혼잡제어를 처리하게 됩니다.

### 왜 HTTP는 TCP를 사용하나요?
HTTP에서 데이터들을 손실 없이 주고받기 위해서는 TCP 프로토콜의 특징인 신뢰성이 중요한 요소이기 때문입니다.

반면 UDP는 3-way-handshake 연결이 없기 때문에 상대적으로 신뢰성을 보장하기 어려운 프로토콜입니다.

### 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
UDP는 TCP보다 더 짧은 지연시간, 더 나은 성능을 제공할 수 있기 때문입니다.

HTTP 3에서는 UDP의 대표적 문제점인 신뢰성 부족 문제를 UDP를 기반으로 하여 그 위에 자체적인 신뢰성 장치를 구현한 QUIC 프로토콜을 사용함으로서 해결하고자 하였습니다.

### 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
HTTP의 버전에 따른 표준 규격이 존재하기 때문에 서버가 지원하는 HTTP 버전을 확인한다면 1,2 버전에서는 TCP, 3 버전이라면 UDP 기반인 QUIC을 사용한다고 파악 가능합니다.

### 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
서버에서 제공하는 서비스가 어떠한 특성을 가지는지가 프로토콜 선택 기준이 될 수 있을 것 같습니다.

신뢰성이 중요한 서버라면 TCP를 선택하는 것이 적절할 것이고, 게임이나 스트리밍처럼 실시간 속도가 중요한 서비스인 경우에는 UDP를 선택하는 것이 좀 더 좋을 것이라고 생각합니다.

## 8. DHCP가 무엇인지 설명해 주세요.
DHCP란 동적 호스트 구성 프로토콜의 약자로, 네트워크 장치에 IP 주소와 서브넷 마스크, 기본 게이트웨이와 같은 기타 관련 구성 정보를 자동으로 제공하는 프로토콜입니다.

수동 IP 설정의 불편함을 해소하고, 자동으로 관련 설정 정보들을 받아올 수 있다는 편리성이 있습니다.

#### 💫  근본적으로 왜 IP 설정이 필요한거죠?
TCP/IP 기반 네트워크의 모든 장치는 네트워크와 리소스에 액세스하기 위해 고유한 유니캐스트 IP 주소가 있어야 합니다. DHCP가 없으면 새 컴퓨터나 한 서브넷에서 다른 서브넷으로 이동한 컴퓨터의 IP 주소는 수동으로 구성해야 하며, 네트워크에서 제거된 컴퓨터의 IP 주소도 수동으로 회수해야 합니다.

### 8-1. DHCP는 몇 계층 프로토콜인가요?
DHCP는 응용 계층 프로토콜입니다.  

### 8-2. DHCP는 어떻게 동작하나요?
가장 먼저 클라이언트가 브로드캐스트로 IP 할당을 요청합니다.
DHCP 서버는 해당 요청을 받고 사용 가능한 IP와 네트워크 설정을 제안합니다.

클라이언트가 해당 제안을 수락하고 최종적으로 서버는 해당 클라이언트의 IP 정보를 기록합니다.

### 8-3. DHCP에서 UDP를 사용하는 이유가 무엇인가요?
IP를 임대하기 이전이라 IP가 존재하지 않는 상황이기 때문에 비연결형 프로토콜인 UDP가 더 적합합니다. 더불어 네트워크 초기 연결에서 빠르게 서로의 응답을 주고받는 과정이 필요하기 때문입니다.

### 8-4. DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?
IP주소 뿐 아니라, 기본 게이트웨이 정보와 서브넷 마스크, 임대 시간, DNS 서버 주소 등을 포함하여 제공합니다.

### 8-5. DHCP의 유효기간은 얼마나 긴가요?
IP 주소의 유효기간은 서버에서 설정한 값에 따라 달라집니다. 일반적으로 24시간을 많이 사용하며, 해당 시간에서 절반이 지나면 클라이언트는 연장 요청을 보내게 됩니다.

## 9. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?
IP주소는 네트워크에 연결된 장치들을 고유하게 식별하는 주소로, 통신에서 패킷의 정확한 목적지를 나타낼 수 있는 역할을 하고 있습니다.

### 9-1. IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?
IPv4에서의 주소 고갈 문제 해결을 위한 대표적인 방법으로 NAT가 있습니다.

NAT를 통해 프라이빗 IP 주소를 퍼블릭 IP로 변환해서 여러 대의 기기가 하나의 퍼블릭 IP를 사용할 수 있게 됩니다.

또 CIDR를 이용해 IP 주소를 좀 더 세밀하게 잘라서 할당할 수 있게 합니다.

### 9-2. IPv4와 IPv6의 차이에 대해 설명해 주세요.
IPv4는 IP주소를 표현하는 데 32비트를 사용하지만, IPv6는 128비트를 사용합니다. 따라서 이를 통해 더 많은 주소를 할당할 수 있게 됩니다.

- 4는 헤더가 복잡하고 6은 헤더가 간단
- 4는 브로드캐스트를 지원, 6은 멀티캐스트 애니캐스트 사용
- 6은 체크섬 없음

### 9-3. 수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?
DHCP 예약 기능을 통해 특정 IP 주소를 특정 MAC 주소에 할당하는 방법을 사용합니다.

### 9-4. IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?
4와 6이 통신 가능합니다. Dual Stack 방식을 통해 장치가 4와 6을 모두 지원하도록 해서 상황에 맞게 선택해서 통신하도록 할 수 있습니다.

그리고 게이트웨이에서 4와 6 사이의 변환을 통해서도 가능합니다.

### 9-5. IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?
IP는 비연결형이며 신뢰성을 보장하지 않습니다. 송신자와 수신자의 정확성을 보장해 주는 것은 전송 계층의 TCP 가 담당합니다.

### 9-6. IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
4에서의 체크섬은 라우팅 과정에서 헤더가 변조되었는지를 확인하기 위해 헤더 내용만 검증합니다.
반면 TCP는 헤더를 포함한 데이터 전체를 검증하는 차이가 있습니다.

### 9-7. TTL(Hop Limit)이란 무엇인가요?
TTL 이란 Time To Live로, 패킷이 생존해 있는 시간을 의미합니다. 패킷이 라우터를 거칠 때마다 TTL 값이 감소하며, 값이 0이되면 해당 패킷은 폐기됩니다.

이를 통해 문제가 있는 패킷이 네트워크를 무한정 돌지 않도록 하는 효과가 있습니다.

### 9-8. IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.
IP 주소는 네트워크 계층에서 사용되며, 네트워크 상에서 장치를 식별하기 위한 주소입니다. IP 주소는 네트워크 환경에 따라 동적으로 변경될 수 있습니다.

반면 MAC 주소는 데이터링크 계층에서 사용되는 NIC에 부여된 고유 식별자입니다.  일반적으로 하드웨어에 고정되어 변경되지 않는 값을 가집니다.

따라서, IP 주소는 데이터를 인터넷과 같은 광범위한 네트워크로 라우팅하는 데 사용되고, MAC 주소는 로컬 네트워크 내에서 장치를 식별하고 통신을 지원하는 데 사용됩니다.

## 10. OSI 7계층에 대해 설명해 주세요.
오픈 시스템 상호 연결(OSI) 모델은 네트워크 통신 기능을 7개의 계층으로 나누는 개념적 모델입니다. 이를 통해 네트워크에서 필요한 다양한 기술이 표준 프로토콜 또는 통신 규칙을 사용하여 통신할 수 있습니다.

각 계층은 특정 기능을 제공하고 해당 기능을 수행해야 네트워킹에 유용하게 사용할 수 있습니다. 상위 계층의 기술은 기본 구현 세부 사항에 대해 걱정할 필요 없이 하위 수준 기술을 사용할 수 있으므로 추상화의 이점을 누릴 수 있습니다.

물리 계층, 데이터링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 프리젠테이션 계층, 애플리케이션 계층 으로 구성되어 있습니다.

### 10-1. Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.
전송 계층은 데이터를 어떤 방법으로 전송할 것인지에 관한 것을 다루며, 신뢰성, 재조립 등을 담당합니다. TCP/UDP이 주요 프로토콜로 사용됩니다.

네트워크 계층은 IP가 사용되는 계층으로, 이를 기반으로 네트워크에서 목적지로 패킷을 이동시키기 위한 라우팅을 담당합니다.

### 10-2. L3 Switch와 Router의 차이에 대해 설명해 주세요.
L3 스위치는 L2 스위치를 기반으로 L3의 라우팅 기술을 함께 제공하는 장비입니다. 따라서 스위칭과 라우팅 기능을 모두 제공하는 반면 라우터는 IP를 가지고 최적화된 네트워크 경로를 찾아서 패킷을 전달하는 역할만을 하는 장치입니다.

즉 L3 스위치가 라우터의 기능에 스위칭 기능까지 함께 지니고 있는 기능이 더 많은 장비라고 이해할 수 있습니다.

#### 💫 라우터와 스위치란?
- 라우터 → IP 주소를 기반으로 패킷이 최종 목적지까지 전달되도록 최적의 경로를 결정하고 전달하는 역할을 함. 3계층에서 작동
- 스위치 → MAC 주소를 기반으로 동일 네트워크 내에서 프레임을 목적지에 전달하는 역할을 함. 2계층에서 작동

### 10-3. 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.
레이어별로 다루는 데이터의 단위가 다르기 때문에 명칭이 모두 다릅니다.

- 물리 계층 → 비트
- 데이터링크 계층 → 프레임
- 네트워크 계층 → 패킷
- 전송 계층 → 세그먼트 / 데이터그램
- 나머지 상위 계층 → 데이터

### 10-4. 각각의 Header의 Packing Order에 대해 설명해 주세요.


### 10-5. ARP에 대해 설명해 주세요.
IP 주소를 MAC 주소로 변환하기 위한 프로토콜입니다. 브로드캐스트를 이용해 네트워크 상의 모든 장치들에게 요청을 보내게 되고, 해당 IP 주소를 가진 장치가 자신의 MAC 주소를 응답하게 됩니다.

## 11. 3-Way Handshake에 대해 설명해 주세요.
3-Way Handshake란 TCP 연결에서 클라이언트와 서버 간에 신뢰성을 위해 연결을 시도하는 매커니즘입니다.

먼저 클라이언트가 서버랑 연결하기 위해 SYN 플래그 비트를 1로 설정하고 보낸다. 이때 클라이언트는 시퀀스 번호와 윈도우 크기값도 함께 전송합니다.

서버가 이 요청을 받으면 정상적으로 받았다는 의미로 SYN=1, ACK=1 로 응답합니다. 서버도 클라이언트에 윈도우 값을 보냅니다.

최종적으로 클라이언트가 서버로부터 헤더를 받으면 ACK=1을 받고 연결이 완료됩니다.

### 11-1. ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
TCP 헤더 내부의 컨트롤 비트 필드에 값을 담아 전달합니다.

### 11-2. 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
최종적으로 클라이언트가 서버의 요청을 확인했다는 요청을 제외하고 두 번의 통신으로만 이루어진 2-Way Handshaking이 이뤄진다면 서버 입장에서는 클라이언트가 통신 준비 완료가 되었는지 알기가 어렵습니다.

따라서 신뢰성 있는 통신을 위해서는 확실하게 양측이 모두 서로의 요청을 확인했고, 통신할 준비가 되었는지를 확인하는 3-Way Handshaking이 필요한 것입니다.

### 11-3. 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?

### 11-4. SYN Flooding 에 대해 설명해 주세요.
TCP handshake 원리를 이용하여, SYN 요청을 대량으로 서버로 전송하는 공격입니다. 

수많은 SYN 요청으로 인해 열린 TCP 연결이 서버 리소스를 소모하게 되어 서버가 올바르게 기능하는 것이 어렵거나 불가능해집니다.

#### 💫 어떠한 방법으로 해당 공격을 방어할 수 있을까요?
중간에 프록시 형태로 방화벽을 설정하여 TCP handshake를 대신 처리하게 하고, 정상적으로 해당 과정이 완료되기 전까지 원 서버와 연결시키는 것을 차단하는 방식이 있을 수 있습니다.

### 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?
0-RTT는 클라이언트와 서버가 서로 연결을 수립할 때 정보를 저장해두었다가, 이후 이전에 연결된 적 있는 클라이언트와 서버가 다시 연결을 수립하게 되면, 저장된 정보를 사용하여 0-RTT로 handshake를 생략하고 즉시 데이터 전송을 할 수 있습니다.

즉, 0-RTT 기법을 사용하기 위해서는 이전에 한 번이라도 연결한 적 있는 클라이언트와 서버여야 합니다. 

## 12. 4-Way Handshake에 대해 설명해 주세요.
4-Way Handshake란 TCP 연결에서 클라이언트와 서버가 연결을 마치고 정상적으로 끊으려고 할 때 진행되는 매커니즘입니다.

연결을 끊길 원하는 측(편의상 클라이언트로 지칭)에서 먼저 컨트롤 비트의 FIN을 1로 설정해서 요청합니다. 그러면 서버가 이 요청을 확인했다는 의미의 ACK 번호를 송신합니다.

그리고 서버도 요청을 끊을 준비가 되면 클라이언트 측으로 FIN을 1로 설정하여 전송합니다. 마지막으로 해당 요청을 받은 클라이언트가 ACK을 보내며 끝나게 됩니다.

#### 💫 왜 종료 요청을 보낼 때 서버는 ACK을 보낸 이후에 따로 FIN을 보내는 걸까요?
통신은 전이중 방식으로 이뤄지기 때문에 양방향으로 데이터를 주고 받게 됩니다.

따라서 클라이언트는 종료할 준비가 되었다고 해도, 서버는 아직 보낼 데이터가 남아 있어서 종료할 준비가 되지 않았을 수 있기 때문입니다. 그래서 일단 종료 요청을 인식하고, 남은 작업을 끝낸 다음 준비가 끝나면 비로소 FIN으로 종료 준비가 되었음을 알려주는 것입니다.

### 12-1. 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
연결을 끊기 위한 측이 먼저 FIN 부분을 1로 설정해서 요청을 보내기 때문에, 이 부분을 확인하면 연결 종료를 위한 4-Why Handshake을 진행해야 하는지를 알 수 있습니다.

### 12-2. 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
컨트롤 비트 필드의 RST(Reset) 플래그를 사용하는 방법이 대표적입니다. 접속을 강제로 종료하며, 이상 상황에서 종료시에 사용됩니다.

### 12-3. 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?

### 12-4. 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것일까요?
종료 후 바로 소켓을 말소하게 되면 오동작이 발생할 수 있어 이를 방지하기 위함입니다.

예를 들면 클라이언트에서 보낸 마지막 ACK 패킷이 손실되는 경우, 서버 측은 응답을 받지 못했으므로 다시 FIN 요청을 재발송할 수도 있습니다. 그런데 잠시 대기하지 않고 클라이언트가 바로 소켓을 말소해버리면 해당 요청을 처리할 수 없게 됩니다.

심지어 만약 그 사이에 새로운 소켓이 생성되어 해당 포트 번호를 사용하는 상황이 되었다면, 새로운 연결에 FIN 요청을 발송해서 오동작할 가능성도 존재합니다. 따라서 이러한 것을 방지하기 위해 TIME_WAIT 상태가 존재하는 것입니다.

## 13. [www.github.com을](http://www.github.xn--com-of0o/) 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.
(다시 더 간단하게 정리 todo)

### 13-1. DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?
클라이언트가 처음에 질의한 도메인 이름이 호스팅된 서버의 주소를 가리킵니다.

### 13-2. Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
웹 서버는 주로 HTML과 CSS등의 정적 콘텐츠를 제공하는 반면, 웹 어플리케이션 서버는 클라이언트의 요청을 기반으로 동적으로 콘텐츠를 생성하여 제공한다는 것에 큰 차이가 있습니다.

### 13-3. URL, URI, URN은 어떤 차이가 있나요?
URL은 Uniform Resource Locator로, 인터넷 상에서 자원의 위치를 표현하기 위한 규약입니다. 리소스의 위치와 프로토콜을 함께 제공하기 때문에, URL을 통해 자원을 어디에서 어떤 프로토콜로 접근해야 하는지를 알 수 있습니다.

URN은 Uniform Resource Name으로, 리소스를 이름만으로 식별합니다. 

URI는 Uniform Resource Identifier로, 인터넷에서 자원을 식별하기 위한 방법입니다. 앞의 두 가지 개념을 포함하는 개념이라고 할 수 있습니다.

## 14. DNS에 대해 설명해 주세요.
서버의 도메인명으로 그에 대응하는 IP 주소를 찾아주는 시스템입니다. 

### 14-1. DNS는 몇 계층 프로토콜인가요?
애플리케이션 계층 프로토콜입니다.

### 14-2. UDP와 TCP 중 어떤 것을 사용하나요?
DNS 요청은 대부분 간단한 쿼리와 응답을 요청하기 때문에, 빠른 속도적 이점이 있는 UDP를 사용합니다. 다만 512 바이트를 초과하는 쿼리와 응답일 경우에는 TCP가 사용됩니다.

### 14-3. DNS Recursive Query, Iterative Query가 무엇인가요?
DNS 재귀적 쿼리는 클라이언트가 IP 주소를 요청하면, 완전한 IP를 알려주거나 혹은 결과가 없다고 하는 응답을 기대하는 쿼리입니다. 
이를 위해 DNS 서버는 최상위 루트 서버에서부터 반복적으로 하위 계층 서버에 요청을 보내며 답을 찾을 때까지 재귀적으로 동작합니다. 답을 찾는다면, 해당 답을 클라이언트에게 반환합니다.

반면, DNS 반복 쿼리는 IP 주소를 요청했을 때 최종적인 결과를 응답받는 것이 아니라 중간 과정을 응답받습니다. 그리고 응답받은 DNS 서버의 주소로 클라이언트가 직접 요청을 보내는 것을 반복하여 최종적으로 결과를 얻을 수 있습니다.

### 14-4. DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
쿼리를 보낸 후 일정 시간동안 응답이 없다면 손실로 간주하고 재발송합니다.

### 14-5. 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
DNS 레코드에는 TTL 설정이 되어 있기 때문에, 캐시가 만료되길 기다릴 수 있습니다. 혹은 강제로 로컬 DNS의 캐시를 지우는 방법도 사용 가능합니다.

### 14-6. DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
A는 IPv4 주소를 의미하고, AAAA는 IPv6 주소를 의미하며, CNAME은 도메인명의 별칭입니다.

### hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
hosts 파일은 로컬 컴퓨터에서 도메인과 IP 주소를 직접 매핑하는 텍스트 파일로, DNS보다 우선순위가 더 높습니다.

## 15. SOP 정책에 대해 설명해 주세요.
SOP란 동일 출처 정책으로, 같은 출처에서의 리소스만 가져올 수 있도록 하는 보안정책입니다. 

### 15-1. CORS 정책이 무엇인가요?
CORS란 교차 출처 리소스 공유로, CORS 정책을 허용한다는 것은 다른 출처에서도 리소스를 주고 받을 수 있도록 한다는 의미입니다.

#### 💫 그렇다면 동일 출처라는 것은 무엇인가요?
프로토콜, 포트, 호스트가 모두 동일할 경우 동일 출처로 여겨집니다.

### 15-2. Preflight에 대해 설명해 주세요.
클라이언트가 서버로 CORS 요청을 보내기 이전에  OPTIONS 메서드를 사용하여 CORS 요청을 전송해도 안전한지 확인하는 절차입니다.

#### 💫 프리플라이트 요청을 하지 않는 경우도 있나요?
다음 조건을 모두 충족하는 경우에는 프리플라이트 요청을 하지 않는 단순 요청이 됩니다.
- GET, HEAD, POST 세 개의 메서드 중 하나
- Accept, Content-Type 등등 특정 헤더만 포함되어야 함
- ReadableStream 객체가 아니어야 함 

## 16. Stateless와 Connectionless에 대해 설명해 주세요.
stateless는 서버가 클라이언트의 이전 상태를 기억하지 않는 특성으로, 서버 자원을 효율적으로 관리할 수 있고 서버의 확장성을 높이는 데 유리한 면을 가집니다. 

connectionless는 클라이언트가 서버에 요청하여 응답을 받는 경우 연결을 끊어서 계속해서 연결이 유지되지 않도록 하는 특성으로, 역시 서버 자원을 효율적으로 관리할 수 있지만 연속적으로 요청과 응답을 주고받아야 할 경우에는 잦은 연결과 해제로 인한 성능 저하를 일으킬 수 있습니다.

### 16-1. 왜 HTTP는 Stateless 구조를 채택하고 있을까요?
서버가 이전 요청에 관한 상태를 기억하지 않아도 되기 때문에 서버 자원을 효율적으로 운용할 수 있고, 많은 클라이언트의 요청을 처리해야 하는 상황에서 확장성이 용이하기 때문입니다.

### 16-2. Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?
HTTP/1.1에서 지속 연결 방법으로 Connectionless의 성능 문제를 해결했습니다. 지속 연결을 통해 한 번의 TCP 연결을 가지고 계속해서 필요한 만큼 여러 번의 요청과 응답을 주고받을 수 있도록 개선되었습니다.

지속 연결을 가능하게 하는 대표적인 방법이 Connection의 keep-alive 헤더입니다.

또한 HTTP/2에서는 멀티플렉싱이 도입되어, 하나의 연결로 여러 요청과 응답을 동시에 처리할 수 있도록 더욱 개선되었습니다.

### 16-3. TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?
TCP의 keep-alive는 TCP 연결 이후에 계속해서 연결이 정상적으로 유지되고 있는지 작은 패킷을 지속적으로 보내면서 확인하는 매커니즘입니다.

반면 HTTP의 keep-alive는 헤더의 keep-alive 값을 확인하여, 해당 시간만큼 TCP 연결을 끊지 않고 기다립니다. 마지막 요청 이후에 시간이 초과되면 TCP 연결이 끊어지게 됩니다.

## 17. 라우터 내의 포워딩 과정에 대해 설명해 주세요. 🌟
- 입력 포트로 들어온 패킷을 수신하는 것에서 시작하며, FCS 검증 등의 방법으로 패킷의 오류를 체크합니다.
- 패킷의 헤더에서 목적지 주소를 확인합니다.
- 포워딩 테이블에서 목적지 주소를 확인하여 출력할 포트와 다음 홉을 결정합니다.
- IP 헤더의 TTL 값을 감소시키고, 헤더의 무결성 확인을 위해 체크섬을 계산합니다.
- 최종적으로 패킷을 출력 인터페이스로 전달합니다.

### 17-1. 라우팅과 포워딩의 차이는 무엇인가요?
라우팅은 패킷을 출발지에서 목적지로 보내기 위해 경로를 설정하는 것을 의미하고, 포워딩은 경로에 따라 출력 포트로 패킷을 실제로 이동시키는 과정을 의미합니다.

즉, 라우팅은 경로 설정에, 포워딩은 실제 패킷 전달에 초점을 맞춥니다.

### 17-2. 라우팅 알고리즘에 대해 설명해 주세요.
네트워크 상에서 패킷을 목적지까지 이동시키기 위한 최적의 이동 경로를 선택하기 위해 사용되는 알고리즘을 의미합니다.

대표적으로 인접 라우터의 정보만을 활용하는 거리 벡터 알고리즘과, 전체 네트워크 정보를 활용하는 링크 상태 알고리즘이 있습니다.

### 17-3. 포워딩 테이블의 구조에 대해 설명해 주세요.
포워딩 테이블은 패킷을 목적지 IP 주소로 보내기 위해 어떤 포트로 전송할지를 확인하기 위한 테이블입니다. 포워딩 테이블은 목적지 네트워크 주소, 넥스트 홉 주소, 어느 포트를 통해 이동시킬지를 표시하는 출력 인터페이스 등의 항목으로 구성됩니다. 

## 18. 로드밸런서가 무엇인가요?
로드밸런서란 서버의 앞단에서 프록시 역할을 하며, 여러 서버로 네트워크 트래픽을 분산하여 서버의 부하를 분산하는 솔루션입니다. 
로드밸런서는 로드밸런싱 알고리즘을 기반으로 트래픽을 분산하여 각 서버의 부담을 줄이고 효율성을 증가시킵니다.
또한, 서버 장애 발생 시에도 트래픽을 다른 정상 서버로 분산하여 고가용성을 보장하며, 쉽게 서버 스케일업이 가능하다는 특징이 있습니다.

### 18-1. L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
L4 로드밸런서는 TCP와 UDP 프로토콜에서 트래픽을 분산합니다. IP와 포트번호를 기반으로 로드 밸런싱을 수행합니다. 패킷의 헤더 정보만을 활용하여 처리 속도가 상대적으로 빠르기 때문에 실시간으로 빠른 트래픽 처리가 필요한 경우 적합합니다.

L7 로드밸런서는 HTTP 레벨에서 트래픽을 분산합니다. L4에서 사용하는 정보에 더해서 URL, 쿠키, HTTP 헤더 등의 요청 내용을 기반으로 로드 밸런싱을 수행합니다.
상대적으로 속도는 느리지만, 다양한 기준으로 유연한 로드밸런싱이 가능합니다. 세부적인 요청에 따른 트래픽 처리가 필요한 경우 적합합니다.

### 18-2. 로드밸런싱 알고리즘에 대해 설명해 주세요.
로드밸런싱 알고리즘에는 대표적으로 다음과 같은 것들이 있습니다.
- **라운드 로빈**은 순차적으로 순회하며 서버를 선택하는 알고리즘입니다. 구현이 가능하지만 서버의 부하 상태를 고려하지 않는다는 한계가 있습니다.
- **최소 연결**은 현재 연결 수가 가장 적은 서버를 선택하는 알고리즘입니다. 연결 수를 측정하여 효율적인 부하분산이 가능하지만, 응답 시간은 고려되지 않습니다.
- **IP 해시**는 클라이언트의 IP 주소를 해싱하여 그 결과를 가지고 특정 서버로 매핑하는 알고리즘입니다. 부하분산의 기준이 해시값에 따라 달라지기 때문에 균등한 부하 분산이 되지 않을 수 있다는 특징이 있습니다.
- **가중치 라운드로빈**은 서버 성능에 따라 가중치를 부여하고 이를 바탕으로 부하를 분산하는 알고리즘입니다.
- **최소 응답 시간** 알고리즘은 서버의 응답 시간을 체크하여 가장 빠른 응답을 하는 서버로 트래픽을 분산합니다. 서버 응답시간을 지속적으로 체크해야 한다는 오버헤드가 있습니다.

### 18-3. 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?
로드밸런서는 서버들이 정상적으로 작동하는지 상태를 체크하기 위해 헬스 체크를 수행합니다. 일반적으로는 특정 요청을 보내서 응답이 돌아오는지를 체크하는 방식으로 작동하며, 이를 통해서 각 서버의 가용성을 확인하고 문제가 발생한 서버로는 부하 분산을 수행하지 않을 수 있습니다.

#### 💫 로드밸런서는 어떻게 서버의 부하를 체크하나요?
웹 서버와 정기적으로 정보를 교환해서 CPU나 메모리 사용률 등을 수집하고, 이것을 바탕으로 어느 웹 서버가 부하가 낮은지 판단하거나 시험 패킷을 보내서 응답 시간으로 부하를 판단하는 방법이 일반적입니다.

웹서버의 부하는 단 시간에 증가하거나 감소하므로 꼼꼼히 상황을 조사하지 않으면 정확한 곳까지 파악할 수 없습니다. 하지만 그렇다고 너무 자세하게 조사하면 부하 조사 동작 자체가 웹 서버의 부하를 증가시키게 되므로 적절한 부하 체크 설정이 중요합니다.

### 18-4. 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.
DNS를 활용하는 로드밸런싱은 특정 도메인에 대해 여러 IP를 DNS에 등록해 두고, DNS 서버는 요청 쿼리에 대해 등록된 IP 주소 중 하나로 응답합니다.
IP 주소를 선택하는 기준은 일반적으로 라운드 로빈 방식과 지리적 가중치를 기반으로 하는 방식을 사용합니다.

구현이 간단하고 지리적으로 트래픽 분산이 가능하다는 장점이 있는 반면에 단순히 등록되어 있는 IP 주소를 응답하는 것이기 때문에 서버의 상태 확인이 불가능하다는 점, DNS 캐싱 때문에 특정 IP로 계속 접속하게 된다는 한계가 있습니다.

## 19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.
서브넷 마스크는 IPv4 주소를 네트워크 부분과 호스트 부분으로 구별하기 위해 사용하는 개념입니다. 이를 통해 네트워크를 논리적으로 분할하여 효율적으로 관리할 수 있게 됩니다.

게이트웨이는 서로 다른 네트워크 사이에 통신을 가능하게 하며, 일반적으로 라우터가 그 역할을 담당합니다.
자신의 네트워크를 벗어나야 하는 패킷을 게이트웨이에 전달하면, 게이트웨이는 라우팅 테이블을 참조하여 패킷을 최종 목적지로 전달합니다.

즉, 서브넷 마스크를 이용해 분리한 네트워크 부분을 벗어나는 목적지의 패킷을 외부 네트워크로 전송하는 역할을 게이트웨이가 한다고 볼 수 있습니다.

### 19-1. NAT에 대해 설명해 주세요.
Network Address Translation는 사설 IP주소를 공인 IP 주소로 변환해주는 네트워크 기술입니다. 이를 통해 IPv4의 주소 부족 문제를 해결할 수 있고, 내부 네트워크의 보안성 향상에 기여할 수 있습니다.

사설 IP와 공인 IP를 일대일로 매핑하는 정적 NAT, 사설 IP주소에 공인 IP 주소 풀에 있는 IP주소 중 하나를 동적으로 할당하는 동적 NAT, 하나의 공인 IP를 여러 사설 IP가 포트 번호로 구분해서 사용하는 PAT 방식이 있습니다.

### 19-2. 서브넷 마스크의 표현 방식에 대해 설명해 주세요.
서브넷 마스크는 32비트를 8비트씩 나누고 각 부분을 0부터 255까지로 표현하고 점으로 구분합니다.

또 다른 표현 방법으로는 슬래시 다음으로 네트워크 부분을 나타내는 비트 수를 표기하여 좀 더 간결하게 나타낼 수 있는 CIDR 방법이 있습니다.

### 19-3. 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?
연속적인 1 혹은 0으로만 이루어져 있어야 네트워크 부분인지 호스트 부분인지 체크할 수 있기 때문에, 해당 형식의 서브넷 마스크는 잘못된 형식입니다.

## 20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.
일반적인 의미의 멀티플렉싱은 여러 신호나 입력을 받아 하나로 출력하는 것을 의미하며, 디멀티플렉싱은 반대로 하나의 입력을 여러개의 출력을 변환해 주는 것입니다.

전송 계층에서 제공하는 멀티플렉싱은 여러 애플리케이션의 데이터를 포트 번호를 기준으로 하여 하나의 데이터 스트림을 통해 전송하도록 하는 것입니다. 이와 반대로 디멀티플렉싱은 받은 데이터 스트림을 포트를 확인하여 나누고 해당되는 애플리케이션으로 전달하는 것을 의미합니다. 

HTTP/2에서 등장하는 멀티플렉싱 개념은 동시에 여러 개의 스트림을 하나의 TCP 커넥션으로 처리하도록 하는 기술이며, 이는 순차적 응답 처리에 따른 HOL Blcoking 문제를 해결합니다.
디멀티플렉싱은 이 하나의 스트림을 받아 각각의 독립적인 데이터로 분리하는 과정을 의미합니다.

### 20-1. 디멀티플렉싱의 과정에 대해 설명해 주세요.

## 21. XSS에 대해서 설명해 주세요.
Cross-Site Scripting은 공격자가 웹 페이지에 악성 스크립트를 삽입하여 실행되도록 하고, 이를 통해 사용자의 쿠키 정보, 세션 ID와 같은 정보를 탈취, 조작하는 공격입니다.

XSS 공격을 방지하기 위한 방법으로는 사용자가 입력한 값에 대해 필터링, 제한을 거는 입력값 검증 방법과 웹 사이트 출력 값에 인코딩 처리를 하여 스크립트가 실행되지 않도록 하는 방법이 있습니다.

### 21-1. CSRF랑 XSS는 어떤 차이가 있나요?
CSRF(Cross-Site Request Forgery)는 공격자가 사용자의 권한을 악용하여 사용자가 의도하지 않은 요청을 서버로 보내도록 하는 공격입니다. 반면, XSS(Cross-Site Scripting)는 공격자가 웹 페이지에 악성 스크립트를 삽입하여 사용자의 정보를 탈취하거나 웹 페이지를 변조하는 공격입니다.

즉, XSS가 사용자가 특정 사이트를 신뢰하기 때문에 발생하는 문제라면, CSRF는 특정 사이트가 사용자를 신뢰 하기 때문에 발생하는 문제라고 할 수 있습니다.

### 21-2. XSS는 프론트엔드에서만 막을 수 있나요?
XSS 공격은 프론트엔드뿐만 아니라 백엔드에서도 방어할 수 있습니다. 백엔드에서 쿠키를 내려줄 때, httpOnly 설정하여 자바스크립트로 쿠키에 접근하는 것을 막는 방법이 있습니다.
